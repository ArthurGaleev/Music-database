--
-- PostgreSQL database dump
--

-- Dumped from database version 17beta3
-- Dumped by pg_dump version 17beta3

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: create_playlist(character varying, boolean, bigint, bigint[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_playlist(name character varying, private boolean, user_id bigint, song_ids bigint[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
-- переменная для нового индекса плейлиста
  new_id BIGINT;
BEGIN
-- проверяем, что таблица не пустая (LIMIT, чтобы быстрее работало)
-- и выбираем новый уникальный индекс плейлиста, например - максимум плюс 1
  if EXISTS ( SELECT * FROM User_playlists LIMIT 1 )
  THEN
    new_id := MAX( ( SELECT id FROM User_playlists ) ) + 1;
  ELSE
    new_id := 0;
  END IF;

  INSERT INTO User_playlists VALUES
  ( new_id, name, private, user_id, song_ids );

-- мы его создали, мы его первый слушатель
-- PERFORM, так как нам не нужен результат SELECT (psql сам подсказал)
  PERFORM listen_playlist( user_id, new_id ); 

END;
$$;


ALTER FUNCTION public.create_playlist(name character varying, private boolean, user_id bigint, song_ids bigint[]) OWNER TO postgres;

--
-- Name: like_song(bigint, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.like_song(user_id bigint, song_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
-- переменная для нового индекса лайка для песни
  new_id BIGINT;
BEGIN
  -- проверяем, что таблица не пустая (LIMIT, чтобы быстрее работало)
  -- и выбираем новый уникальный индекс лайка для песни, например - максимум плюс 1
  if EXISTS ( SELECT * FROM Liked_songs LIMIT 1 )
  THEN
    new_id := MAX( ( SELECT id FROM Liked_songs ) ) + 1;
  ELSE
    new_id := 0;
  END IF;

  INSERT INTO Liked_songs
  VALUES ( new_id, user_id, song_id );
END;
$$;


ALTER FUNCTION public.like_song(user_id bigint, song_id bigint) OWNER TO postgres;

--
-- Name: listen_playlist(bigint, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.listen_playlist(user_id bigint, playlist_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF ( SELECT private FROM User_playlists WHERE id = playlist_id )
  THEN
    RAISE EXCEPTION 'This playlist is for private use only';
  END IF;

  UPDATE Users
    SET playlist_ids_history = ARRAY_APPEND(playlist_ids_history, playlist_id)
  WHERE id = user_id;
END;
$$;


ALTER FUNCTION public.listen_playlist(user_id bigint, playlist_id bigint) OWNER TO postgres;

--
-- Name: listen_song(bigint, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.listen_song(user_id bigint, song_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE Users
    SET song_ids_history = array_append(song_ids_history, song_id)
  WHERE id = user_id;
END;
$$;


ALTER FUNCTION public.listen_song(user_id bigint, song_id bigint) OWNER TO postgres;

--
-- Name: playlist_id_by_name(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.playlist_id_by_name(playlist_name character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN ( SELECT id FROM Playlist
           WHERE Playlist.name = playlist_name );
END;
$$;


ALTER FUNCTION public.playlist_id_by_name(playlist_name character varying) OWNER TO postgres;

--
-- Name: song_id_by_name(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.song_id_by_name(song_name character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN ( SELECT id FROM Songs
           WHERE Songs.name = song_name );
END;
$$;


ALTER FUNCTION public.song_id_by_name(song_name character varying) OWNER TO postgres;

--
-- Name: update_composition_popularity(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_composition_popularity() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
-- переменная только что прослушанной песни 
-- (для ускорения, так как нужно воспользоваться несколько раз)
  last_song_id BIGINT;
BEGIN
  last_song_id := NEW.song_ids_history[ARRAY_LENGTH( NEW.song_ids_history, 1 )];

  -- инкрементируем популярность прослушанной песни
  UPDATE Songs
    SET popularity = popularity + 1
  WHERE Songs.id = last_song_id;
    
  -- инкрементируем популярность прослушанного артиста
  UPDATE Artists
    SET popularity = popularity + 1
  WHERE Artists.id = ( SELECT artist_id FROM Songs WHERE Songs.id = last_song_id );

  -- инкрементируем популярность прослушанного альбома
  UPDATE Albums
    SET popularity = popularity + 1
  WHERE Albums.id = ( SELECT album_id FROM Songs WHERE Songs.id = last_song_id );

  -- инкрементируем популярность прослушанного жанра
  UPDATE Genres
    SET popularity = popularity + 1
  WHERE Genres.id = ( SELECT genre_id FROM Songs WHERE Songs.id = last_song_id );
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_composition_popularity() OWNER TO postgres;

--
-- Name: update_playlist_popularity(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_playlist_popularity() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- здесь, в отличие от update_composition_popularity можно 
-- без переменной, так как она требуется только в одном месте
BEGIN
  -- инкрементируем популярность прослушанного плейлиста
  UPDATE User_playlists
    SET popularity = popularity + 1
  WHERE User_playlists.id = NEW.playlist_ids_history[ARRAY_LENGTH( NEW.playlist_ids_history, 1 )];
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_playlist_popularity() OWNER TO postgres;

--
-- Name: user_id_by_name(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.user_id_by_name(user_name character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN ( SELECT id FROM Users
           WHERE Users.name = user_name );
END;
$$;


ALTER FUNCTION public.user_id_by_name(user_name character varying) OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: albums; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.albums (
    id bigint NOT NULL,
    name character varying(64) NOT NULL,
    artist_id bigint NOT NULL,
    song_ids bigint[],
    popularity bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.albums OWNER TO postgres;

--
-- Name: artists; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.artists (
    id bigint NOT NULL,
    name character varying(64) NOT NULL,
    country_id smallint NOT NULL,
    popularity bigint DEFAULT 0
);


ALTER TABLE public.artists OWNER TO postgres;

--
-- Name: countries; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.countries (
    id smallint NOT NULL,
    name character varying(64) NOT NULL
);


ALTER TABLE public.countries OWNER TO postgres;

--
-- Name: genres; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.genres (
    id smallint NOT NULL,
    name character varying(64) NOT NULL,
    popularity bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.genres OWNER TO postgres;

--
-- Name: liked_songs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.liked_songs (
    id bigint NOT NULL,
    user_id bigint NOT NULL,
    song_id bigint NOT NULL
);


ALTER TABLE public.liked_songs OWNER TO postgres;

--
-- Name: songs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs (
    id bigint NOT NULL,
    name character varying(64) NOT NULL,
    artist_id bigint NOT NULL,
    album_id bigint NOT NULL,
    genre_id smallint NOT NULL,
    popularity bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.songs OWNER TO postgres;

--
-- Name: user_playlists; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_playlists (
    id bigint NOT NULL,
    name character varying(64) NOT NULL,
    private boolean DEFAULT true NOT NULL,
    user_id bigint NOT NULL,
    song_ids bigint[],
    popularity bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.user_playlists OWNER TO postgres;

--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    id bigint NOT NULL,
    name character varying(64) NOT NULL,
    country_id smallint NOT NULL,
    song_ids_history bigint[],
    playlist_ids_history bigint[]
);


ALTER TABLE public.users OWNER TO postgres;

--
-- Data for Name: albums; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.albums (id, name, artist_id, song_ids, popularity) FROM stdin;
2	Ride the Lightning	1	\N	0
4	Higher Truth	2	\N	2
3	Master of Puppets	1	\N	1
5	American Pie	3	\N	5
0	The Getaway	0	\N	6
1	Stadium Arcadium	0	\N	10
\.


--
-- Data for Name: artists; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.artists (id, name, country_id, popularity) FROM stdin;
2	Chris Cornell	1	2
1	Metallica	0	1
3	Don Mclean	2	5
0	RHCP	0	16
\.


--
-- Data for Name: countries; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.countries (id, name) FROM stdin;
0	USA
1	Australia
2	Denmark
\.


--
-- Data for Name: genres; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.genres (id, name, popularity) FROM stdin;
1	Metal	1
2	Country	5
0	Alternative rock	18
\.


--
-- Data for Name: liked_songs; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.liked_songs (id, user_id, song_id) FROM stdin;
0	2	3
1	0	5
2	0	9
3	2	9
4	3	9
5	1	1
6	1	0
7	2	4
8	3	4
9	1	9
10	0	7
11	3	7
12	1	3
13	1	5
14	3	2
15	2	3
16	2	0
17	1	4
\.


--
-- Data for Name: songs; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.songs (id, name, artist_id, album_id, genre_id, popularity) FROM stdin;
0	Fade to Black	1	2	1	0
1	Vincent	3	5	2	1
2	Before We Disappear	2	4	0	2
8	Enter The Sandman	1	3	1	1
3	Scar Tissue	0	1	0	3
4	Snow	0	1	0	3
5	Empty Chairs	3	5	2	4
6	Go Robot	0	0	0	3
7	Dark Necessities	0	0	0	3
9	Slow Cheetah	0	1	0	4
\.


--
-- Data for Name: user_playlists; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.user_playlists (id, name, private, user_id, song_ids, popularity) FROM stdin;
1	To chill	t	1	{1,3,4,7,9}	0
2	Nostalgia	f	5	{0,1,5}	2
0	For the weekend	f	3	{3,4,6,9}	4
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users (id, name, country_id, song_ids_history, playlist_ids_history) FROM stdin;
4	Николай	2	\N	\N
0	Ваня	1	{2,3,4,7}	{0,2}
1	Паша	1	{1,4,5,9}	{0}
2	Алексей	1	{2,3,5,6,9}	{0}
3	Стас	0	{5,6,7,8,9}	{2}
5	Андрей	0	{3,4,5,6,7,9}	{0}
\.


--
-- Name: albums albums_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.albums
    ADD CONSTRAINT albums_pkey PRIMARY KEY (id);


--
-- Name: artists artists_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.artists
    ADD CONSTRAINT artists_pkey PRIMARY KEY (id);


--
-- Name: countries countries_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.countries
    ADD CONSTRAINT countries_pkey PRIMARY KEY (id);


--
-- Name: genres genres_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.genres
    ADD CONSTRAINT genres_pkey PRIMARY KEY (id);


--
-- Name: liked_songs liked_songs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.liked_songs
    ADD CONSTRAINT liked_songs_pkey PRIMARY KEY (id);


--
-- Name: songs songs_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs
    ADD CONSTRAINT songs_name_key UNIQUE (name);


--
-- Name: songs songs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs
    ADD CONSTRAINT songs_pkey PRIMARY KEY (id);


--
-- Name: user_playlists user_playlists_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_playlists
    ADD CONSTRAINT user_playlists_name_key UNIQUE (name);


--
-- Name: user_playlists user_playlists_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_playlists
    ADD CONSTRAINT user_playlists_pkey PRIMARY KEY (id);


--
-- Name: users users_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_name_key UNIQUE (name);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: users playlist_listened; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER playlist_listened AFTER UPDATE OF playlist_ids_history ON public.users FOR EACH ROW EXECUTE FUNCTION public.update_playlist_popularity();


--
-- Name: users song_listened; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER song_listened AFTER UPDATE OF song_ids_history ON public.users FOR EACH ROW EXECUTE FUNCTION public.update_composition_popularity();


--
-- Name: albums albums_artist_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.albums
    ADD CONSTRAINT albums_artist_id_fkey FOREIGN KEY (artist_id) REFERENCES public.artists(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: artists artists_country_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.artists
    ADD CONSTRAINT artists_country_id_fkey FOREIGN KEY (country_id) REFERENCES public.countries(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: liked_songs liked_songs_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.liked_songs
    ADD CONSTRAINT liked_songs_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: songs songs_album_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs
    ADD CONSTRAINT songs_album_id_fkey FOREIGN KEY (album_id) REFERENCES public.albums(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: songs songs_artist_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs
    ADD CONSTRAINT songs_artist_id_fkey FOREIGN KEY (artist_id) REFERENCES public.artists(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: songs songs_genre_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs
    ADD CONSTRAINT songs_genre_id_fkey FOREIGN KEY (genre_id) REFERENCES public.genres(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: user_playlists user_playlists_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_playlists
    ADD CONSTRAINT user_playlists_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: users users_country_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_country_id_fkey FOREIGN KEY (country_id) REFERENCES public.countries(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- PostgreSQL database dump complete
--